Funkcje 
- Search - ogólna funkcja, która pozwala szukać w tabelach na podstawie sortowania po wpisaniu frazy/ 
People 
    - Wyświetlanie w tabeli 
        - Pracowników(imię, pozycja, numer telefonu)
        - po rozwinięciu komórki pracownika pokazuje szczegółowe dane 
            - Szczegółowe dane( brak funkcji - tylko ich wyświetlenie) 
            - Zdjęcie 
            - Funkcjonalne: 
                - ZWOLNIJ PRACOWNIKA 
                - Pokaż kontrakt 
                    - Obowiązujący kontrakt (od, do) typ kontraktu, pozycja f.drukuj 
                - Ostatnie zarobki 
                    - Tablea ostatnich wypłat 
                - Tasks 
                    - Table przyszłych zaplanowanych zadań
                - Kalendarz 
                    - Pokazuję plan na obecny tydzień, bez możliwości edycji 
                    - Możlwiość przejścia do zakładki kalendarz z importem danego pracownika 
Tasks
Contracts 
Finance 
Calendar 
- wyświetlany na podstawie osób lub na podstawie zadań  
- Dla osób możliwe jest ustalenie rutyny czyli godzin pracy 
    - USTAL PRACĘ DLA PRACOWNIKA 
        - Podanie czasu, dnia i powtarzalności 
        - Choroba/Urlop
            - Ze względu na chorobe lub urlop pracownika system szuka pracownika, który przyjdzie na zastępstwo (propozycje), dla osoby która idzie na urlop lub na chorobowe jest to uwzględnianie przy kalkulacji wynagrodzenia. 
    - Dodanie zadania - w czasie trwania pracy danej osoby możliwe dodanie zadania, za które jest odpowiedzialny 
        - Deadline 
        - Odpowiedzialność
        - Współpracownicy 
    - Dodanie wydarzenia 
        - Opis 
        - Czas miejsce itd

PROTOTYP FRONTENDU:

Elementy zakładki pracownicy:

OBIEKT SearchItemEmployee - jego zadaniem jest konstrukcja zapytania wyszukującego i zwrócenie w konkretne miejsce wyników otrzymanych z serwera. Wysyła zapytania po klinięciu przycisku X, po Z sekundach od nic-nie-wpisywania, po kliknięciu na klawiaturze Y
Wysyła JSON pt. "search_employee"
Odbiera JSON pt. "employee_results"

Funkcje dotyczące rozwijania/zwijania po kliknięciu przycisków w liście rezultatów pracowników //Rozważyć opakowanie listy w obiekt

OBIEKT EmployeeSingleTab - jego zadaniem jest poprawne przechowywanie pojedynczego pracownika, obsługa wydarzeń z nim związanych [np przejście do kalendarza za pomocą przycisku, klinięcie zwolnij itd...], wyświetlanie go w miesjcu X. Te obiekty będą tworzone "maszynowo", na bieżąco, będzie ich możliwie wiele.
Wysyła JSON pt. "employee_data_details"
Odbiera JSON pt. "employee_details_results"

Dużo funkcji które obsługiwać będą akcje związane z pojedynczym pracownikiem. Będzie dużo JSONów. Będą one wylistowane pod wspólną etykietą 
"employee_operations_XXX" gdzie XXX to nazwy poszczególnych operacji. (W - wysyła, O - odbiera)

"employee_operations_fire" W
"employee_operations_fire_check" O
"employee_operations_get_contract" W
"employee_operations_get_contract_check" O
prawdopodobnie będziemy implementować więcej ... 

Elementy zakładki kalendarz:

OBIEKT BigSizeCalendar - jego zadaniem jest utworzenie w kontenerze XXX interaktywnego kalendarza. Kalendarz dba o automatyczne wczytywanie porcji danych [wyświetla 1 miesiąc naraz, za każdym razem gdy przełącza się, kreowane jest nowe zapytanie do serwera]. Możliwa zmiana widoku, kreowane są wtedy też zapytania. Implementacja automatycznego odświeżania [w przypadku gdy jest >1 operator serwera]
Kreuje obiekt CalendarObjectRoutineSet, CalendarObjectIllnessSet, CalendarObjectTaskCreator, CalendarObjectEventCreator po kliknięciu odp. przycisków
Obiekt dba o poprawne wykonywanie się animacji
Wysyła JSONY: "calendar_get_for_users" "calendar_get_for_tasks" "calendar_get_for_events" "calendar_refresh" (ROBIMY optymalizacje tak, żeby te jsony działały także gdy przechodzimy z widoku pracowników"
Odbiera JSONY: "calendar_get_for_users_results" "calendar_get_for_tasks_results calendar_get_delta" "calendar_get_for_results"

OBIEKT CalendarObjectRoutineSet - kreowany dynamicznie - tabelka mówiąca o możliwości stworzenia dla danego użytkownika YYY rutyny "Ustal pracę dla pracownika". Wieńczona jest wyjściem z tabu, bądź sfinalizowaniem komunikacji i wysłaniem zapytania. Po odbiorze JSONów potwierdzających wywołuje w kalendarzu REFRESH.
Wysyła JSONY: "calendar_set_routine"
Odbiera JSONY: "calendar_routine_set" // potwierdzenie ustawienia

OBIEKT CalendarObjectIllnessSet - kreowany dynamicznie - tabelka\dialog dzięki któremu będziemy mogli a) znaleźć pracownika na zastępstwo, b) wstawić osobie status "urlop", czy też "chorobowe" przez co zmieni się grafik w istocie dwóch osób [zastępca i nieobecny]. Po odbiorze JSONów potwierdzających wywołuje w kalendarzu REFRESH.
Wysyła JSONY: "calendar_set_illness" "calendar_look_for_fill"
Odbiera JSONY: "calendar_set_illness_check" "calendar_look_for_fill_results"

OBIEKT CalendarObjectTaskCreator - kreowany dynamicznie - tabelka dzięki której możemy dodać zadanie do X użytkowników. Będzie ono wykonywane w możliwych do ustalenia terminach pracy poszczególnych osób, będzie można ustalać odpowiedzialność za Y, Z itd ... Można ustalić deadline. Po zakończonej pracy wysyłamy JSON
Wysyła JSON: "calendar_create_task"
Odbiera JSON: "calendar_task_created"

OBIEKT CalendarObjectEventCreator - kreowany dynamicznie - tabelka dzięki której dodamy wydarzenie (globalne, lokalne, dla grupy). Stosunkowo prosta sprawa. Składa się z tytułu, opisu, czasu trwania i terminu. Operujemy na JSONach:
Wysyła JSON: "calendar_create_event"
Odbiera JSON: "calendar_event_created"


----------------------------------------

SPIS WSZYSTKICH JSONÓW:
tytuł JSON'a przekazujemy jako parametr "type" w środku
"search_employee" = JSON{
	name = ""
	surname = ""
	section = ""
	birthplace = "" ... itd, wszystkie wyszukiwane wartości
	type = "search_employee" TO BĘDZIE WSZĘDZIE
	sorting_type = tablica dla powyższych pól typu {1: "ascending",2: "descending",3: "ascending"}
}
"employee_results" = JSON{
	tab_results[..ileś wpisów..] = {}
	status = {good, error, none ... }
}
"employee_data_details" = JSON{
	user_id = id z bazy
	user_status = jeśli będzie wiele tabel, to tutaj zidentyfikujemy której tabele w bazie użyjemy [lub coś podobnego, do identyfikacji]
}
"employee_details_results" = JSON{
	name = ""
	lastPayments = []
	hasContract = true
	itd ... wszystkie dane jakie będziemy używać
	status = {good, error, ...}
}
"employee_operations_fire" = JSON{
	user_id = id użytkownika
	PIN/password = operacja niebezpieczna, wymaga potwierdzenia czymś	
}
"employee_operations_fire_check" = JSON{
	status = {fired, cannot_be_fired, error, ..}
}
"employee_operations_get_contract" = JSON{
	user_id = którego użytkownika?
}
"employee_operations_get_contract_check" = JSON{
	dane kontraktu / albo link do pliku...
	...
	...
	status
	
}
"calendar_get_for_users" = JSON{
	users_list = [tutaj kolejni użytkownicy którzy będą naniesieni na kalendarz] lista użytkowników do wypisania. Pusta lista - błąd]
}
"calendar_get_for_tasks" = JSON{
	tasks_list = [lista tasków do pokazania na kalendarzu, pusta lista - błąd]
}
"calendar_get_for_events" = JSON{
	nic ... 
}
"calendar_get_for_events_results" = JSON{
	events_data = [
			dane o wydarzeniach do wpisania na kalendarz
			]
}
"calendar_get_for_users_results" = JSON{
	users_data = [
		1: {terminy, id użytkownika, itd dla pierwszego gościa OBIEKT} 
		2: {jak powyżej, dla gościa 2 ...}
		3: ...
	] tablica
	status = {good, error, no_results}
}
"calendar_get_for_tasks_results" = JSON{
	tasks_data = [
		1: {terminy, id tasku, osoby zaangażowane itd dla tasku 1}
		2: {to co wyżej dla tasku 2 ..}
		3: ...
	]
}
"calendar_refresh" = JSON{
	mode = aktualny tryb
	prev_timestamp = data służąca do porównania tego, czy pojawiło sie coś nowego od ostatniego wczytania
}
"calendar_get_delta" = JSON{
	users_data
	tasks_data
	events_data .. tak jak powyżej, to informacje do wpisania na kalendarz
	status = {good, error, ... }
}
"calendar_set_routine" = JSON{
	user_id DLA KOGO?
	timestamps = [od kiedy do kiedy w tablicy, np "pon 12.00 - 17.00", "wt ..." ...]
	name
	description
	... inne dane do rutyny
}
"calendar_routine_set" = JSON{
	status = {set, error, cannot be set}
	err_description = ""
}
"calendar_set_illness" = JSON{
	date_start 
	date_end
	reason = "" powód, nieformalny opis
	holiday_type = formalny typ [ENUM], na podstawie tego obliczamy to i tamto
	fill_in = [tablica zastępujących gościa ludzi w odpowiednich terminach. Po stronie serwera trzeba będzie przeprowadzić weryfikacje sensowności i spójności fill_in'ów i trwania zwolnienia
	termin 1 -> gościu z tym indeksem
	termin 2 -> gościu z tym indeksem itd	
	]
	password/PIN raczej nie chcemy ustawić tego przypadkowo
}
"calendar_look_for_fill" = JSON{
	date_start
	date_end
	user_id
	Po stronie serwera będzie to skomplikowane żądanie. Serwer powinien zwrócić nam NAJLEPSZE propozycje zastępstwa w tym terminie biorąc pod uwagę to jakie taski miał w tym terminie robić ten co się zwalnia, do jakich grup należy, w jakich terminach może go zastąpić (stosunek ile_moze_godzin_go_zastapic/calkowita_dlugosc_zwolnienia) musi być jak najbliszy 1
}
"calendar_set_illness_check" = JSON{
	result = {not_set_no_fill, not_set_fill, set_fill, set_no_fill, error} fill - jest możliwe zastępstwo, set - ustawiono zwolnienie
	prop_to_fill_in = [] system proponuje te zastępstwa
	status = {ok, error, ..}
}
"calendar_look_for_fill_results" = JSON{
	posegregowane 
	fill_ins = [
	user_1: {terminy gdzie może zastąpić w tablicy, imie, nazwisko, id goscia, dzial gdzie robi, wspolne taski}
	user_2: {tak jak wyzej}
	itd ...
	]
	status = {ok, error, ...}
} 
"calendar_create_task" = JSON{
	name
	description
	deadline
	coworkers
	problem_category
	timeline = [
		USER 1 zajmuje się tym w czasie XX - YY
		USER 2 zajmuje się tym w czasie ZZ - DD
	...
	]
}
"calendar_task_created" = JSON{
	status = {created, not_created, error, ...}
}
"calendar_create_event" = JSON{
	date
	duration
	group = "" nazwa grupy, brak oznacza - dla wszystkich
	name
	description
	photo?
}
"calendar_event_created" = JSON{
	status = {created, not_created, error}
	//można rozpatrzeć żeby system dawał ostrzeżenia że ktoś robi coś w trakcie wydarzenia
}

