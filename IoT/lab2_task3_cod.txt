#define BUTTON_BLUE 2
#define BUTTON_RED 4

#include<Wire.h> 
//Biblioteka do obsługi wyświetlacza LCD
include <Wire.h> 
#include <LiquidCrystal.h>  // Aleternative vs. #include <LiquidCrystal_I2C.h> 
LiquidCrystal lcd(12, 11, 5, 4, 3, 2); //Alterative vs. LiquidCrystal_I2C lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);

float holder = 0; 

bool lastRedState = HIGH; 
bool curRedState = HIGH;
bool lastBlueState = HIGH; 
bool curBlueState = HIGH;
bool backlight = true; 

String wiadomosc = "";

String buffor[10] = {};
int lineNumber = 0;
int cursorLine = 0;
int textScrollPositon[2] = {0,0}; // first and second row describe text align respectivly  
int bufforSize[10] = {};

void writeToLine(String line,int length, int linePositon){ // writing line to buffor 
  buffor[linePositon] = line;
  bufforSize[linePositon] = length;
  lineNumber = linePositon;
}


void writeAndGoNext(String line,int length){ // writing line to buffor and jumps to next line
  writeToLine(line, length, lineNumber);
  lineNumber++;
  if(lineNumber>9) // in case of extending size it will go back to begining 
    lineNumber = 0;
}

void setup() {
  Serial.begin(9600);
  lcd.begin(16, 2);
  pinMode(BUTTON_BLUE, INPUT_PULLUP);  
  pinMode(BUTTON_RED, INPUT_PULLUP);     
  
}

void loop() { 
  lcd.setCursor(0, 0);
  for(int icurs = 0; icurs<2;icurs++){
    
    lcd.print(buffor[cursorLine+icurs].substring(textScrollPositon[icurs], textScrollPositon[icurs]+16)); // pritning line and cut it to make it fit in screen size, also moving it every iteration to right until text ends
    if(buffor[cursorLine+icurs].length()<17){
    	lcd.setCursor(buffor[cursorLine+icurs].length(), icurs);
      for(int i = buffor[cursorLine+icurs].length(); i<17; i++){
        lcd.print(' '); 
      }
    }

    lcd.setCursor(0, 1);
  }
  if(Serial.available() > 0) { 
    wiadomosc = Serial.readStringUntil('\n');  
	writeAndGoNext(wiadomosc, wiadomosc.length()-1);// User puts data into buffer
  }  
  
  textScrollPositon[0]++; 
  textScrollPositon[1]++;
  if(bufforSize[cursorLine]<14+textScrollPositon[0]){
    textScrollPositon[0] = 0;
  }
  if(bufforSize[cursorLine+1]<14+textScrollPositon[1]){
    textScrollPositon[1] = 0;
  }
  
  curRedState = digitalRead(BUTTON_RED); // increment of cursor line
  if(lastRedState != curRedState){
    delay(40);
    if(curRedState == LOW){
      cursorLine++;
    }
  }
  lastRedState = curRedState;
  
  curBlueState = digitalRead(BUTTON_BLUE); // decrement of cursor line
  if(lastBlueState != curBlueState){
    delay(40);
    if(curBlueState == LOW){
      cursorLine--;
    }
  }
  lastBlueState = curBlueState;
  if(cursorLine<0)
    cursorLine = 0;
  else if(cursorLine>9)
    cursorLine = 9;
  
  delay(40); // update every 40 milisc

}
